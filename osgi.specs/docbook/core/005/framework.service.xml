<?xml version="1.0" encoding="utf-8"?>
<!--
    Copyright (c) Contributors to the Eclipse Foundation
   
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
   
        http://www.apache.org/licenses/LICENSE-2.0
   
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
   
    SPDX-License-Identifier: Apache-2.0 
 -->

<chapter label="5" revision="$Id$"
         version="5.0" xml:id="framework.service"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Service Layer</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.framework-version"
    linkend="org.osgi.framework"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>The OSGi Service Layer defines a dynamic collaborative model that is
    highly integrated with the Life Cycle Layer. The
    <emphasis>service</emphasis> model is a publish, find and bind model. A
    service is a normal Java object that is registered under one or more Java
    interfaces with the service registry. Bundles can register services,
    search for them, or receive notifications when their registration state
    changes.</para>

    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Collaborative</emphasis> - The service layer must
          provide a mechanism for bundles to publish, find, and bind to each
          other's services without having a priori knowledge of those
          bundles.</para>
        </listitem>

        <listitem>
          <para><emphasis>Dynamic</emphasis> - The service mechanism must be
          able to handle changes in the outside world and underlying
          structures directly.</para>
        </listitem>

        <listitem>
          <para><emphasis>Secure</emphasis> - It must be possible to restrict
          access to services.</para>
        </listitem>

        <listitem>
          <para><emphasis>Reflective</emphasis> - Provide full access to the
          Service Layer's internal state.</para>
        </listitem>

        <listitem>
          <para><emphasis>Versioning</emphasis> - Provide mechanisms that make
          it possible to handle the fact that bundles and their services
          evolve over time.</para>
        </listitem>

        <listitem>
          <para><emphasis>Persistent Identifier</emphasis> - Provide a means
          for bundles to track services across Framework restarts.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Service</emphasis> - An object registered with the
          service registry under one or more interfaces together with
          properties. The service can be discovered and used by
          bundles.</para>
        </listitem>

        <listitem>
          <para><emphasis>Service Registry</emphasis> - Holds the service
          registrations.</para>
        </listitem>

        <listitem>
          <para><emphasis>Service Reference</emphasis> - A reference to a
          service. Provides access to the service's properties but not the
          actual service object. The service object must be acquired through a
          bundle's Bundle Context.</para>
        </listitem>

        <listitem>
          <para><emphasis>Service Registration</emphasis> - The receipt
          provided when a service is registered. The service registration
          allows the update of the service properties and the unregistration
          of the service.</para>
        </listitem>

        <listitem>
          <para><emphasis>Service Permission</emphasis> - The permission to
          use an interface name when registering or using a service.</para>
        </listitem>

        <listitem>
          <para><emphasis>Service Scope</emphasis> - Indicates how service
          objects are obtained when requesting a service object. The following
          service scopes are defined: <emphasis>singleton</emphasis>,
          <emphasis>bundle</emphasis>, and <emphasis>prototype</emphasis>. The
          default service scope is <emphasis>singleton</emphasis>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Service Factory</emphasis> - A facility to let the
          registering bundle customize the service object for each using
          bundle. When using a Service Factory, the service scope of the
          service is <emphasis>bundle</emphasis>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Prototype Service Factory</emphasis> - A facility to
          let the registering bundle customize the service object for each
          caller. When using a Prototype Service Factory, the service scope of
          the service is <emphasis>prototype</emphasis>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Service Objects</emphasis> - A facility to let the
          using bundle obtain multiple service objects for a service with
          <emphasis>prototype</emphasis> service scope.</para>
        </listitem>

        <listitem>
          <para><emphasis>Service Listener</emphasis> - A listener to Service
          Events.</para>
        </listitem>

        <listitem>
          <para><emphasis>Service Event</emphasis> - An event holding
          information about the registration, modification, or unregistration
          of a service object.</para>
        </listitem>

        <listitem>
          <para><emphasis>Filter</emphasis> - An object that implements a
          simple but powerful filter language. It can select on
          properties.</para>
        </listitem>

        <listitem>
          <para><emphasis>Invalid Syntax Exception</emphasis> - The exception
          thrown when a filter expression contains an error.</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>Class Diagram <code>org.osgi.framework</code><emphasis> Service
        Layer</emphasis></title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="4.538in"
                       contentwidth="6.221in" fileref="service-classes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section>
    <title>Services</title>

    <para>In the OSGi framework, bundles are built around a set of cooperating
    services available from a shared service registry. Such an OSGi service is
    defined semantically by its <emphasis>service interface</emphasis> and
    implemented as a <emphasis>service object</emphasis>.</para>

    <para>The service interface should be specified with as few implementation
    details as possible. OSGi has specified many service interfaces for common
    needs and will specify more in the future.</para>

    <para>The service object is owned by, and runs within, a bundle. This
    bundle must register the service object with the Framework service
    registry so that the service's functionality is available to other bundles
    under control of the Framework.</para>

    <para>Dependencies between the bundle owning the service and the bundles
    using it are managed by the Framework. For example, when a bundle is
    stopped, all the services registered with the Framework by that bundle
    must be automatically unregistered.</para>

    <para>The Framework maps services to their underlying service objects, and
    provides a simple but powerful query mechanism that enables a bundle to
    request the services it needs. The Framework also provides an event
    mechanism so that bundles can receive events of services that are
    registered, modified, or unregistered.</para>

    <section xml:id="framework.service.servicereferences">
      <title>Service References</title>

      <para>In general, registered service objects are referenced through
      <code>ServiceReference</code> objects. This avoids creating unnecessary
      dynamic service dependencies between bundles when a bundle needs to know
      about a service but does not require the service object itself.</para>

      <para>A <code>ServiceReference</code> object can be stored and passed on
      to other bundles without the implications of dependencies. A
      <code>ServiceReference</code> object encapsulates the properties and
      other meta-information about the service object it represents. This
      meta-information can be queried by a bundle to assist in the selection
      of a service that best suits its needs.</para>

      <para>When a bundle queries the Framework service registry for services,
      the Framework must provide the requesting bundle with the
      <code>ServiceReference</code> objects of the requested services, rather
      than with the services themselves. See <xref
      linkend="framework.service.locating"/>.</para>

      <para>A <code>ServiceReference</code> object may also be obtained from a
      <code>ServiceRegistration</code> object.</para>

      <para>A <code>ServiceReference</code> object is valid only as long as
      the service is registered. However, its properties must remain available
      as long as the <code>ServiceReference</code> object exists.</para>

      <para>When a bundle wishes to use the service object, it can be obtained
      by using the <code>ServiceReference</code>. See <xref
      linkend="framework.service.getting"/>.</para>
    </section>

    <section>
      <title>Service Interfaces</title>

      <para>A <emphasis>service interface</emphasis> is the specification of
      the service's public methods.</para>

      <para>In practice, a bundle developer creates a service object by
      implementing its service interface and registers the service object with
      the Framework service registry. Once a bundle has registered a service
      object under an interface name, the associated service can be acquired
      by bundles under that interface name, and its methods can be accessed by
      way of its service interface. The Framework also supports registering
      service objects under a class name, so references to service interface
      in this specification can be interpreted to be an interface or
      class.</para>

      <para>When requesting a service object from the Framework, a bundle can
      specify the name of the service interface that the requested service
      object must implement. In the request, the bundle may also specify a
      filter string to narrow the search.</para>

      <para>Many service interfaces are defined and specified by organizations
      such as the OSGi Working Group. A service interface that has been accepted as
      a standard can be implemented and used by any number of bundle
      developers.</para>
    </section>

    <section xml:id="framework.service.registeringservices">
      <title>Registering Services</title>

      <para>A bundle publishes a service by registering a service object with
      the Framework service registry. A service object registered with the
      Framework is exposed to other bundles installed in the OSGi
      environment.</para>

      <para>Every registered service object has a unique
      <code>ServiceRegistration</code> object, and has one or more
      <code>ServiceReference</code> objects that refer to it. These
      <code>ServiceReference</code> objects expose the registration properties
      of the service, including the set of service interfaces they implement.
      The <code>ServiceReference</code> object can then be used to acquire a
      service object that implements the desired service interface.</para>

      <para>The Framework permits bundles to register and unregister service
      objects dynamically. Therefore, a bundle is permitted to register
      service objects at any time during the <code>STARTING</code>,
      <code>ACTIVE</code> or <code>STOPPING</code> states.</para>

      <para>A bundle registers a service object with the Framework by calling
      one of the <code>BundleContext.registerService</code> methods on its
      <code>BundleContext</code> object:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.framework.BundleContext.registerService-String-Object-Dictionary-"
          xrefstyle="hyperlink"/> - For a service object registered under a
          single service interface.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.framework.BundleContext.registerService-String---Object-Dictionary-"
          xrefstyle="hyperlink"/> - For a service object registered under
          multiple service interfaces.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.framework.BundleContext.registerService-Class-S-Dictionary-"
          xrefstyle="hyperlink"/> - For a service object registered under a
          single service interface using the class object for the interface
          name.</para>
        </listitem>
      </itemizedlist>

      <para>The names of the service interfaces under which a bundle wants to
      register its service are provided as arguments to the
      <code>registerService</code> methods. The Framework must ensure that the
      service object actually is an instance of each specified service
      interfaces, unless the object is a Service Factory. See <xref
      linkend="framework.service.serviceFactory"/> and <xref
      linkend="framework.service.prototypeServiceFactory"/>.</para>

      <para>To perform this check, the Framework must load the
      <code>Class</code> object for each specified service interface from
      either the bundle or a shared package. For each <code>Class</code>
      object, <code>Class.isInstance</code> must be called and return
      <code>true</code> on the <code>Class</code> object with the service
      object as the argument.</para>

      <para>The service object being registered may be further described by a
      <code>Dictionary</code> object, which contains the properties of the
      service as a collection of key/value pairs. The methods <xref
      linkend="org.osgi.framework.FrameworkUtil.asMap-Dictionary-"
      xrefstyle="hyperlink"/> and <xref
      linkend="org.osgi.framework.FrameworkUtil.asDictionary-Map-"
      xrefstyle="hyperlink"/> can be helpful when working with service
      properties to provide Map views over Dictionaries and Dictionary views
      over Maps.</para>

      <para>The service interface names under which a service object has been
      successfully registered are automatically added to the service's
      properties under the key <code>objectClass</code>. This value must be
      set automatically by the Framework and any value provided by the bundle
      must be overridden.</para>

      <para>If the service object is successfully registered, the Framework
      must return a <code>ServiceRegistration</code> object to the caller. A
      service object can be unregistered only by the holder of its
      <code>ServiceRegistration</code> object (see the <xref
      linkend="org.osgi.framework.ServiceRegistration.unregister--"
      xrefstyle="hyperlink"/> method). Every successful service object
      registration must yield a unique <code>ServiceRegistration</code> object
      even if the same service object is registered multiple times.</para>

      <para>Using the <code>ServiceRegistration</code> object is the only way
      to reliably change the service's properties after it has been registered
      (see the <xref
      linkend="org.osgi.framework.ServiceRegistration.setProperties-Dictionary-"
      xrefstyle="hyperlink"/> method). Modifying a service's
      <code>Dictionary</code> object after the service object is registered
      may not have any effect on the service's properties.</para>

      <para>The process of registering a service object is subject to a
      permission check. The registering bundle must have
      <code>ServicePermission[&lt;name&gt;,REGISTER]</code> to register the
      service object under all the service interfaces specified. Otherwise,
      the service object must not be registered, and a
      <code>SecurityException</code> must be thrown.</para>
    </section>

    <section xml:id="i2061648">
      <title>Early Need for ServiceRegistration Object</title>

      <para>The registration of a service object will cause all registered
      <code>ServiceListener</code> objects to be notified. This is a
      synchronous notification. This means that such a listener can get access
      to the service and call its methods before the
      <code>registerService</code> method has returned the
      <code>ServiceRegistration</code> object. In certain cases, access to the
      <code>ServiceRegistration</code> object is necessary in such a callback.
      However, the registering bundle has not yet received the
      <code>ServiceRegistration</code> object. <xref linkend="i2058495"
      xrefstyle="template:Figure %n on page %p"/> shows such a
      sequence.</para>

      <figure xml:id="i2058495">
        <title>Service Registration and registration</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.870in"
                       contentwidth="4.942in"
                       fileref="registration-actions.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>In a case as described previously, access to the registration
      object can be obtained via a <code>ServiceFactory</code> object or
      <code>PrototypeServiceFactory</code> object. If a
      <code>ServiceFactory</code> object or
      <code>PrototypeServiceFactory</code> object is registered, the Framework
      must call-back the registering bundle with the
      <code>ServiceFactory</code> method <xref
      linkend="org.osgi.framework.ServiceFactory.getService-Bundle-ServiceRegistration-"
      xrefstyle="hyperlink"/> or the <code>PrototypeServiceFactory</code>
      method <xref
      linkend="org.osgi.framework.PrototypeServiceFactory.getService-Bundle-ServiceRegistration-"
      xrefstyle="hyperlink"/>. The required <code>ServiceRegistration</code>
      object is passed as a parameter to these methods.</para>
    </section>

    <section xml:id="framework.service.serviceproperties">
      <title>Service Properties</title>

      <para>Properties hold information as key/value pairs. The key must be a
      <code>String</code> object and the value should be a type recognized by
      <code>Filter</code> objects (see <xref linkend="i2671413"/> for a list).
      Multiple values for the same key are supported with arrays ([]) and
      <code>Collection</code> objects.</para>

      <para>The values of properties should be limited to primitive or
      standard Java types to prevent unwanted inter bundle dependencies. The
      Framework cannot detect dependencies that are created by the exchange of
      objects between bundles via the service properties.</para>

      <para xml:id="i2070445">The key of a property is not case sensitive.
      <code>ObjectClass</code>, <code>OBJECTCLASS</code> and <code>
      objectclass</code> all are the same property key. A Framework must
      return the key in <code>ServiceReference.getPropertyKeys</code> in
      exactly the same case as it was last set. When a <code>Dictionary</code>
      object that contains keys that only differ in case is passed, the
      Framework must raise an exception.</para>

      <para>The service properties are intended to provide information
      <emphasis>about</emphasis> the service. The properties should not be
      used to participate in the actual function of the service. Modifying the
      properties for the service registration is a potentially expensive
      operation. For example, a Framework may pre-process the properties into
      an index during registration to speed up later look-ups.</para>

      <para>The <code>Filter</code> interface supports complex filtering; it
      can be used to find matching services. Therefore, all properties share a
      single namespace in the Framework service registry. As a result, it is
      important to use descriptive names or formal definitions of shorter
      names to prevent conflicts. Several OSGi specifications reserve parts of
      this namespace. All properties starting with the prefix
      <code>service</code>. and the property <code>objectClass</code> are
      reserved for use by OSGi specifications.</para>

      <para><xref linkend="framework.service-service.properties"/> contains a
      list of pre-defined properties.</para>

      <table xml:id="framework.service-service.properties">
        <title>Standard Service Properties (+ indicates scalar, array of, or
        collection of)</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="1.8*"/>

          <colspec colnum="2" colwidth="0.8*"/>

          <colspec colnum="3" colwidth="2*"/>

          <colspec colnum="4" colwidth="3.4*"/>

          <thead>
            <row>
              <entry>Property Key</entry>

              <entry>Type</entry>

              <entry>Constants</entry>

              <entry>Property Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>objectClass</code><superscript>†</superscript></entry>

              <entry><code>String[]</code></entry>

              <entry><para xml:id="i2070464"><xref
              linkend="org.osgi.framework.Constants.OBJECTCLASS"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>The <code>objectClass</code> property contains the
              set of interface names under which a service object is
              registered with the Framework. The Framework must set this
              property automatically. The Framework must guarantee that when a
              service object is retrieved with <xref
              linkend="org.osgi.framework.BundleContext.getService-ServiceReference-"
              xrefstyle="hyperlink"/>, it can be cast to any of the interface
              names.</para></entry>
            </row>

            <row>
              <entry><code>service.bundleid</code><superscript>†</superscript></entry>

              <entry><code>Long</code></entry>

              <entry><para><xref
              linkend="org.osgi.framework.Constants.SERVICE_BUNDLEID"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>The <code>service.bundleid</code> property
              identifies the bundle registering the service. The Framework
              must set this property automatically with the value of the
              bundle id of the registering bundle.</para></entry>
            </row>

            <row>
              <entry><code>service.description</code></entry>

              <entry><code>String</code></entry>

              <entry><para xml:id="i2070467"><xref
              linkend="org.osgi.framework.Constants.SERVICE_DESCRIPTION"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para xml:id="i2070468">The
              <code>service.description</code> property is intended to be used
              as documentation and is optional. Frameworks and bundles can use
              this property to provide a short description of a registered
              service object. The purpose is mainly for debugging because
              there is no support for localization.</para></entry>
            </row>

            <row>
              <entry><code>service.id</code><superscript>†</superscript></entry>

              <entry><code>Long</code></entry>

              <entry><para><xref
              linkend="org.osgi.framework.Constants.SERVICE_ID"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Every registered service object is assigned a
              unique, non-negative <code>service.id</code> by the Framework.
              This number is added to the service's properties. The Framework
              assigns a unique, non-negative value to every registered service
              object that is larger than values provided to all previously
              registered service objects.</para></entry>
            </row>

            <row>
              <entry><code>service.pid</code></entry>

              <entry><code>String+</code></entry>

              <entry><para><xref
              linkend="org.osgi.framework.Constants.SERVICE_PID"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>The <code>service.pid</code> property optionally
              identifies a persistent, unique identifier for the service
              object. See <xref linkend="i3043166"/>.</para></entry>
            </row>

            <row>
              <entry><code>service.scope</code><superscript>†</superscript></entry>

              <entry><code>String</code></entry>

              <entry><para><xref
              linkend="org.osgi.framework.Constants.SERVICE_SCOPE"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>The <code>service.scope</code> property identifies
              the service's scope. The Framework must set this property
              automatically. If the registered service object implements <xref
              linkend="org.osgi.framework.PrototypeServiceFactory"
              xrefstyle="hyperlink"/>, then the value will be <link
              linkend="org.osgi.framework.Constants.SCOPE_PROTOTYPE"
              xrefstyle="hyperlink">prototype</link>. Otherwise, if the
              registered service object implements <xref
              linkend="org.osgi.framework.ServiceFactory"
              xrefstyle="hyperlink"/>, then the value will be <link
              linkend="org.osgi.framework.Constants.SCOPE_BUNDLE"
              xrefstyle="hyperlink">bundle</link>. Otherwise, the value will
              be <link linkend="org.osgi.framework.Constants.SCOPE_SINGLETON"
              xrefstyle="hyperlink">singleton</link>. See <xref
              linkend="framework.service.scope"/>.</para></entry>
            </row>

            <row>
              <entry><code>service.ranking</code></entry>

              <entry><code>Integer</code></entry>

              <entry><para xml:id="i2070487"><xref
              linkend="org.osgi.framework.Constants.SERVICE_RANKING"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>See <xref
              linkend="framework.service.servicerankingorder"/>.</para></entry>
            </row>

            <row>
              <entry><code>service.vendor</code></entry>

              <entry><code>String</code></entry>

              <entry><para xml:id="i2070492"><xref
              linkend="org.osgi.framework.Constants.SERVICE_VENDOR"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>This optional property can be used by the bundle
              registering the service object to indicate the
              vendor.</para></entry>
            </row>

            <row>
              <entry><code>service.changecount</code></entry>

              <entry><code>Long</code></entry>

              <entry><para><link
              linkend="org.osgi.framework.Constants.SERVICE_CHANGECOUNT"
              xrefstyle="hyperlink">SERVICE_</link></para><para><link
              linkend="org.osgi.framework.Constants.SERVICE_CHANGECOUNT"
              xrefstyle="hyperlink">CHANGECOUNT</link></para></entry>

              <entry><para>This optional property can be used by the bundle
              registering the service object to indicate there has been a
              change in some data provided by the service.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para><superscript>†</superscript> The values for these service
      properties must be set by the Framework. Any values specified for these
      service properties during service registration or service properties
      update must be ignored.</para>
    </section>

    <section xml:id="framework.service.servicerankingorder">
      <title>Service Ranking Order</title>

      <para>When registering a service object, a bundle may optionally specify
      a <xref linkend="org.osgi.framework.Constants.SERVICE_RANKING"
      xrefstyle="hyperlink"/> service property of type <code>Integer</code>.
      This number specifies a ranking order between services. The highest
      number has the highest ranking and the lowest number (including negative
      numbers) has the lowest ranking. If no <code>service.ranking</code>
      service property is specified or its type is not <code>Integer</code>
      then a ranking of 0 must be used.</para>

      <para>The <emphasis>ranking order</emphasis> is defined as
      follows:</para>

      <itemizedlist>
        <listitem>
          <para>Sorted on descending ranking number (highest first)</para>
        </listitem>

        <listitem>
          <para>If the ranking numbers are equal, sorted on ascending
          <code>service.id</code> property (oldest first).</para>
        </listitem>
      </itemizedlist>

      <para>This ordering is complete because service ids are never reused and
      handed out in order of their registration time. That is, a service that
      is registered later will have a higher service id. Therefore, the
      ranking order is in descending <code>service.ranking</code> numeric
      order where ties give a preference to the earlier registrant.</para>

      <para>The ranking order is the reverse of the natural ordering of a
      <code>ServiceReference</code> object.</para>

      <para>The purpose of the ranking order is to allow:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Selection</emphasis> - When a single service must be
          chosen but multiple services qualify then the service with the
          highest ranking must be selected.</para>
        </listitem>

        <listitem>
          <para><emphasis>Ordering</emphasis> - When multiple services must be
          used in a specified order.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="i3043166">
      <title>Persistent Identifier (PID)</title>

      <para>The purpose of a Persistent Identifier (PID) is to identify a
      service across Framework restarts. Services that can reference the same
      underlying entity every time they are registered should therefore use a
      service property that contains a PID. The name of the service property
      for PID is defined as <code>service.pid</code>. The PID is a unique
      identifier for a service that persists over multiple invocations of the
      Framework. For a given service, the same PID should always be used. If
      the bundle is stopped and later started, the same PID must always be
      used.</para>

      <para>The format of the PID should be:</para>

      <programlisting>    pid ::= symbolic-name                   // See <xref
          linkend="framework.general.syntax" xrefstyle="template:%n"/></programlisting>
    </section>

    <section xml:id="framework.service.locating">
      <title>Locating Services</title>

      <para>In order to use a service object and call its methods, a bundle
      must first obtain a <code>ServiceReference</code> object. The
      <code>BundleContext</code> interface defines a number of methods a
      bundle can call to obtain <code>ServiceReference</code> objects from the
      Framework:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.framework.BundleContext.getServiceReference-String-"
          xrefstyle="hyperlink"/>, <xref
          linkend="org.osgi.framework.BundleContext.getServiceReference-Class-"
          xrefstyle="hyperlink"/> - These methods returns a
          <code>ServiceReference</code> object to a service object that
          implements, and was registered under, the name of the specified
          service interface. If multiple such service objects exist, a
          <code>ServiceReference</code> object to the service object with the
          highest <xref linkend="org.osgi.framework.Constants.SERVICE_RANKING"
          xrefstyle="hyperlink"/> is returned. If there is a tie in ranking, a
          <code>ServiceReference</code> object to the service object with the
          lowest <xref linkend="org.osgi.framework.Constants.SERVICE_ID"
          xrefstyle="hyperlink"/> (the service object that was registered
          first) is returned. If no matching service objects are registered
          then <code>null</code> must be returned.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.framework.BundleContext.getServiceReferences-String-String-"
          xrefstyle="hyperlink"/>, <xref
          linkend="org.osgi.framework.BundleContext.getServiceReferences-Class-String-"
          xrefstyle="hyperlink"/> - These methods returns an array or
          collection, respectively, of <code>ServiceReference</code> objects
          for service objects that:</para>

          <itemizedlist>
            <listitem>
              <para>Implement and were registered under the specified service
              interface.</para>
            </listitem>

            <listitem>
              <para>Satisfy the search filter specified. The filter syntax is
              further explained in <xref linkend="i2671413"/>.</para>
            </listitem>
          </itemizedlist>

          <para>If no matching service objects are registered then
          <code>null</code> must be returned by the <xref
          linkend="org.osgi.framework.BundleContext.getServiceReferences-String-String-"
          xrefstyle="hyperlink"/> method and an empty collection must be
          returned by the <xref
          linkend="org.osgi.framework.BundleContext.getServiceReferences-Class-String-"
          xrefstyle="hyperlink"/> method.</para>
        </listitem>
      </itemizedlist>

      <para>The caller receives zero or more <code>ServiceReference</code>
      objects. These objects can be used to retrieve properties of the
      underlying service, or they can be used to obtain the actual service
      object. See <xref linkend="framework.service.getting"/>.</para>

      <para>The above methods require that the caller has the necessary
      <code>ServicePermission[ServiceReference, GET]</code> to get the service
      object for the returned Service Reference. If the caller lacks the
      required permission, these methods must not include that Service
      Reference in the result.</para>
    </section>

    <section>
      <title>Getting Service Properties</title>

      <para>To allow for interrogation of service properties, the
      <code>ServiceReference</code> interface defines these two
      methods:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.framework.ServiceReference.getPropertyKeys--"
          xrefstyle="hyperlink"/> - Returns an array of the property keys that
          are available.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.framework.ServiceReference.getProperty-String-"
          xrefstyle="hyperlink"/> - Returns the value of a property.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.framework.ServiceReference.getProperties--"
          xrefstyle="hyperlink"/> - Returns a copy of the properties.</para>
        </listitem>
      </itemizedlist>

      <para>Both of these methods must continue to provide information about
      the referenced service object, even after it has been unregistered from
      the Framework. This requirement can be useful when a
      <code>ServiceReference</code> object is stored with the Log
      Service.</para>
    </section>

    <section>
      <title>Information About Services</title>

      <para>The <code>Bundle</code> interface defines these two methods for
      returning information pertaining to service usage of the bundles:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.framework.Bundle.getRegisteredServices--"
          xrefstyle="hyperlink"/> - Returns the <code>ServiceReference</code>
          objects for the service objects that the bundle has registered with
          the Framework.</para>
        </listitem>

        <listitem>
          <para><xref linkend="org.osgi.framework.Bundle.getServicesInUse--"
          xrefstyle="hyperlink"/> - Returns the <code>ServiceReference</code>
          objects for the service objects that the bundle is currently
          using.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="i3061523">
      <title>Service Exceptions</title>

      <para>The Service Exception is a Run Time exception that can be used by
      the Framework to report errors or by user code that needs to signal a
      problem with a service. An exception type available from this exception
      provides the detailed information about the problem that caused the
      exception to be thrown.</para>

      <para>Implementations of the framework or user code are allowed to throw
      sub classes of the <code>ServiceException</code> class. If a sub class
      is thrown for a reason other than one of the specified types, then the
      type should be set to <xref
      linkend="org.osgi.framework.ServiceException.SUBCLASSED"
      xrefstyle="hyperlink"/>. Sub classes that provide additional information
      for a specified type should use the specified type.</para>
    </section>

    <section>
      <title>Services and Concurrency</title>

      <para>Services published on one thread and obtained on another thread
      must be safe to use. That is, the Framework must guarantee that there is
      a <emphasis>happens-before</emphasis> relationship between the time a
      service is registered and the time a service object or Service Reference
      is obtained. That is both the registering and obtaining threads must be
      properly synchronized with each other.</para>
    </section>
  </section>

  <section xml:id="framework.service.scope">
    <title>Service Scope</title>

    <para>The <xref linkend="org.osgi.framework.Constants.SERVICE_SCOPE"
    xrefstyle="hyperlink"/> service property identifies the scope of the
    registered service object. The following service scopes are supported by
    the Framework:</para>

    <itemizedlist>
      <listitem>
        <para><xref linkend="org.osgi.framework.Constants.SCOPE_SINGLETON"
        xrefstyle="hyperlink"/> - Identifies the registered service object as
        a single service object which will be used by all bundles requesting
        the service object.</para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.framework.Constants.SCOPE_BUNDLE"
        xrefstyle="hyperlink"/> - Identifies the registered service object as
        a Service Factory. A Service Factory allows the registering bundle to
        customize the service object for each bundle requesting the service
        object. See <xref linkend="framework.service.serviceFactory"/></para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.framework.Constants.SCOPE_PROTOTYPE"
        xrefstyle="hyperlink"/> - Identifies the registered service object as
        a Prototype Service Factory. A Prototype Service Factory allows the
        registering bundle to customize the service object for each request
        for the service object. See <xref
        linkend="framework.service.prototypeServiceFactory"/>.</para>
      </listitem>
    </itemizedlist>

    <para>The Framework must set the <xref
    linkend="org.osgi.framework.Constants.SERVICE_SCOPE"
    xrefstyle="hyperlink"/> service property automatically depending on the
    type of registered service object. If the registered service object
    implements <xref linkend="org.osgi.framework.PrototypeServiceFactory"
    xrefstyle="hyperlink"/>, then the value must be <xref
    linkend="org.osgi.framework.Constants.SCOPE_PROTOTYPE"
    xrefstyle="hyperlink"/>. Otherwise, if the registered service object
    implements <xref linkend="org.osgi.framework.ServiceFactory"
    xrefstyle="hyperlink"/>, then the value must be <xref
    linkend="org.osgi.framework.Constants.SCOPE_BUNDLE"
    xrefstyle="hyperlink"/>. Otherwise, the value must be <xref
    linkend="org.osgi.framework.Constants.SCOPE_SINGLETON"
    xrefstyle="hyperlink"/>. The <xref
    linkend="org.osgi.framework.Constants.SERVICE_SCOPE"
    xrefstyle="hyperlink"/> service property allows bundles to determine
    whether multiple service objects can be obtained for the service.
    Component models like Declarative Services and Blueprint need to know if
    they can properly obtain multiple service objects for referenced
    services.</para>
  </section>

  <section xml:id="framework.service.getting">
    <title>Getting Service Objects</title>

    <para>There are two methods available to get service objects from the
    service registry:</para>

    <itemizedlist>
      <listitem>
        <para><xref linkend="org.osgi.framework.BundleContext"
        xrefstyle="hyperlink"/>.<xref
        linkend="org.osgi.framework.BundleContext.getService-ServiceReference-"
        xrefstyle="hyperlink"/> - This method should be used if the using
        bundle only needs a single service object.</para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.framework.ServiceObjects"
        xrefstyle="hyperlink"/>.<xref
        linkend="org.osgi.framework.ServiceObjects.getService--"
        xrefstyle="hyperlink"/> - This method should be used if the service
        has <xref linkend="org.osgi.framework.Constants.SCOPE_PROTOTYPE"
        xrefstyle="hyperlink"/> scope and the using bundle needs multiple
        service objects.</para>
      </listitem>
    </itemizedlist>

    <para>These methods are used to obtain an actual service object so that
    the Framework can manage dependencies. If a bundle retrieves a service
    object, that bundle becomes dependent upon the life cycle of the
    registered service object. This dependency is tracked by the
    <code>BundleContext</code> object used to obtain the service object,
    directly or indirectly by a <code>ServiceObjects</code> object, and is one
    reason that it is important to be careful when sharing
    <code>BundleContext</code> and <code>ServiceObjects</code> objects with
    other bundles.</para>

    <section xml:id="framework.service.gettingSingle">
      <title>Getting a Single Service Object</title>

      <para>The <code>BundleContext</code> is used when a bundle only needs a
      single service object. The <xref
      linkend="org.osgi.framework.BundleContext" xrefstyle="hyperlink"/>.<xref
      linkend="org.osgi.framework.BundleContext.getService-ServiceReference-"
      xrefstyle="hyperlink"/> method returns an object that implements the
      interfaces as defined by the <code>objectClass</code> property. A bundle
      making multiple calls to this method, without releasing the service
      object, will receive the same service object.</para>

      <para>This method has the following characteristics:</para>

      <itemizedlist>
        <listitem>
          <para>Returns <code>null</code> if the underlying service object has
          been unregistered.</para>
        </listitem>

        <listitem>
          <para>Determines if the caller has
          <code>ServicePermission[ServiceReference,GET]</code>, to get a
          service object associated with the specified Service Reference. This
          permission check is necessary so that <code>ServiceReference</code>
          objects can be passed around freely without compromising
          security.</para>
        </listitem>

        <listitem>
          <para>Increments the usage count of the service by one for this
          <code>BundleContext</code> object.</para>
        </listitem>

        <listitem>
          <para>If the service has <xref
          linkend="org.osgi.framework.Constants.SCOPE_SINGLETON"
          xrefstyle="hyperlink"/> scope then the registered service object is
          returned. Otherwise, if the bundle context's usage count of the
          service is one, the registered service object is cast to a <xref
          linkend="org.osgi.framework.ServiceFactory" xrefstyle="hyperlink"/>
          object and the <xref
          linkend="org.osgi.framework.ServiceFactory.getService-Bundle-ServiceRegistration-"
          xrefstyle="hyperlink"/> method is called to create a customized
          service object for the calling bundle which is then cached and
          returned. Otherwise, a cached copy of this customized service object
          is returned. See <xref linkend="framework.service.serviceFactory"/>
          for more information about <code>ServiceFactory</code>
          objects.</para>
        </listitem>
      </itemizedlist>

      <para>The <xref linkend="org.osgi.framework.BundleContext"
      xrefstyle="hyperlink"/>.<xref
      linkend="org.osgi.framework.BundleContext.getService-ServiceReference-"
      xrefstyle="hyperlink"/> method will only return a single service object
      for the bundle even if the service has <xref
      linkend="org.osgi.framework.Constants.SCOPE_PROTOTYPE"
      xrefstyle="hyperlink"/> scope. See <xref
      linkend="framework.service.gettingMultiple"/> for information on how to
      obtain multiple service objects for a service with <xref
      linkend="org.osgi.framework.Constants.SCOPE_PROTOTYPE"
      xrefstyle="hyperlink"/> scope.</para>
    </section>

    <section xml:id="framework.service.gettingMultiple">
      <title>Getting Multiple Service Objects</title>

      <para>A <xref linkend="org.osgi.framework.ServiceObjects"
      xrefstyle="hyperlink"/> object is used when the service has <xref
      linkend="org.osgi.framework.Constants.SCOPE_PROTOTYPE"
      xrefstyle="hyperlink"/> scope and a bundle needs multiple service
      objects. A <code>ServiceObjects</code> object is associated with a
      single service and is obtained by calling the <xref
      linkend="org.osgi.framework.BundleContext" xrefstyle="hyperlink"/>.<xref
      linkend="org.osgi.framework.BundleContext.getServiceObjects-ServiceReference-"
      xrefstyle="hyperlink"/> method. The caller must have
      <code>ServicePermission[ServiceReference,GET]</code>, to get a
      <code>ServiceObjects</code> object for a service.</para>

      <para>The <xref linkend="org.osgi.framework.ServiceObjects"
      xrefstyle="hyperlink"/>.<xref
      linkend="org.osgi.framework.ServiceObjects.getService--"
      xrefstyle="hyperlink"/> method can be used to obtain multiple service
      objects for the <link
      linkend="org.osgi.framework.ServiceObjects.getServiceReference--">associated</link>
      service.</para>

      <para>This method has the following characteristics for a service with
      <xref linkend="org.osgi.framework.Constants.SCOPE_PROTOTYPE"
      xrefstyle="hyperlink"/> scope:</para>

      <itemizedlist>
        <listitem>
          <para>Returns <code>null</code> if the underlying service object has
          been unregistered.</para>
        </listitem>

        <listitem>
          <para>The registered service object is cast to a <xref
          linkend="org.osgi.framework.PrototypeServiceFactory"
          xrefstyle="hyperlink"/> object and the <xref
          linkend="org.osgi.framework.PrototypeServiceFactory.getService-Bundle-ServiceRegistration-"
          xrefstyle="hyperlink"/> method is called to create a customized
          service object. See <xref
          linkend="framework.service.prototypeServiceFactory"
          xrefstyle="hyperlink"/> for more information about
          <code>PrototypeServiceFactory</code> objects.</para>
        </listitem>

        <listitem>
          <para>The usage count for the customized service object is
          incremented.</para>
        </listitem>

        <listitem>
          <para>The customized service object is returned.</para>
        </listitem>
      </itemizedlist>

      <para>The <xref linkend="org.osgi.framework.ServiceObjects"
      xrefstyle="hyperlink"/>.<xref
      linkend="org.osgi.framework.ServiceObjects.getService--"
      xrefstyle="hyperlink"/> method will only return a single service object
      for the bundle if the service has <xref
      linkend="org.osgi.framework.Constants.SCOPE_SINGLETON"
      xrefstyle="hyperlink"/> or <xref
      linkend="org.osgi.framework.Constants.SCOPE_BUNDLE"
      xrefstyle="hyperlink"/> scope. That is, the method behaves the same as
      the <xref linkend="org.osgi.framework.BundleContext"
      xrefstyle="hyperlink"/>.<xref
      linkend="org.osgi.framework.BundleContext.getService-ServiceReference-"
      xrefstyle="hyperlink"/> method and only a single service object is
      available. See <xref linkend="framework.service.gettingSingle"/>.</para>
    </section>
  </section>

  <section xml:id="framework.service.releasing">
    <title>Releasing Service Objects</title>

    <para>A bundle must release a service object to remove the dynamic
    dependency on the bundle that registered the service object. Depending on
    how a service object was <link
    linkend="framework.service.getting">obtained</link>, one of the following
    methods is used to release a service object:</para>

    <itemizedlist>
      <listitem>
        <para><xref linkend="org.osgi.framework.BundleContext"
        xrefstyle="hyperlink"/>.<xref
        linkend="org.osgi.framework.BundleContext.ungetService-ServiceReference-"
        xrefstyle="hyperlink"/> - This method should be used if the bundle is
        using a single service object and needs to release the single service
        object. See <xref linkend="framework.service.gettingSingle"/>.</para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.framework.ServiceObjects"
        xrefstyle="hyperlink"/>.<xref
        linkend="org.osgi.framework.ServiceObjects.ungetService-S-"
        xrefstyle="hyperlink"/> - This method should be used if the bundle is
        using multiple service objects and needs to release one of the service
        objects. See <xref
        linkend="framework.service.gettingMultiple"/>.</para>
      </listitem>
    </itemizedlist>

    <section xml:id="framework.service.releasingSingle">
      <title>Releasing a Single Service Object</title>

      <para>The <code>BundleContext</code> interface defines a method to
      release a single service object: <xref
      linkend="org.osgi.framework.BundleContext.ungetService-ServiceReference-"
      xrefstyle="hyperlink"/></para>

      <para>This method has the following characteristics:</para>

      <itemizedlist>
        <listitem>
          <para>If the usage count of the service for this
          <code>BundleContext</code> object is zero or the service has been
          unregistered, <code>false</code> is returned.</para>
        </listitem>

        <listitem>
          <para>The usage count of the service for this
          <code>BundleContext</code> object is decremented by one.</para>
        </listitem>

        <listitem>
          <para>If the usage count of the service for this
          <code>BundleContext</code> object is now zero and the service has
          <xref linkend="org.osgi.framework.Constants.SCOPE_BUNDLE"
          xrefstyle="hyperlink"/> or <xref
          linkend="org.osgi.framework.Constants.SCOPE_PROTOTYPE"
          xrefstyle="hyperlink"/> scope, the registered service object is cast
          to a <xref linkend="org.osgi.framework.ServiceFactory"
          xrefstyle="hyperlink"/> object and the <xref
          linkend="org.osgi.framework.ServiceFactory.ungetService-Bundle-ServiceRegistration-S-"
          xrefstyle="hyperlink"/> method is called to release the previously
          cached customized service object for the calling bundle. The cached
          customized service object must be unreferenced by the Framework so
          it may be garbage collected. See <xref
          linkend="framework.service.serviceFactory"/> for more information
          about <code>ServiceFactory</code> objects.</para>
        </listitem>

        <listitem>
          <para><code>true</code> is returned.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="framework.service.releasingMultiple">
      <title>Releasing Multiple Service Objects</title>

      <para>A <code>ServiceObjects</code> object can be used to obtain
      multiple service objects for the <link
      linkend="org.osgi.framework.ServiceObjects.getServiceReference--"
      xrefstyle="hyperlink">associated</link> service if the service has <xref
      linkend="org.osgi.framework.Constants.SCOPE_PROTOTYPE"
      xrefstyle="hyperlink"/> scope. The <code>ServiceObjects</code> interface
      defines a method to release one of the service objects obtained by a
      bundle: <xref
      linkend="org.osgi.framework.ServiceObjects.ungetService-S-"
      xrefstyle="hyperlink"/>. If the associated service has <xref
      linkend="org.osgi.framework.Constants.SCOPE_SINGLETON"
      xrefstyle="hyperlink"/> or <xref
      linkend="org.osgi.framework.Constants.SCOPE_BUNDLE"
      xrefstyle="hyperlink"/> scope, this method behaves the same as calling
      the <xref linkend="org.osgi.framework.BundleContext"
      xrefstyle="hyperlink"/>.<xref
      linkend="org.osgi.framework.BundleContext.ungetService-ServiceReference-"
      xrefstyle="hyperlink"/> method.</para>

      <para>For a service with <xref
      linkend="org.osgi.framework.Constants.SCOPE_PROTOTYPE"
      xrefstyle="hyperlink"/> scope, the following steps are required to
      release the specified service object:</para>

      <itemizedlist>
        <listitem>
          <para>If the associated service has been unregistered, this method
          returns without doing anything.</para>
        </listitem>

        <listitem>
          <para>If the specified service object is <code>null</code> or was
          not provided by a <code>ServiceObjects</code> for the <link
          linkend="org.osgi.framework.ServiceObjects.getServiceReference--"
          xrefstyle="hyperlink">associated</link> service, then an
          <code>IllegalArgumentException</code> is thrown.</para>
        </listitem>

        <listitem>
          <para>The usage count for the specified service object is
          decremented.</para>
        </listitem>

        <listitem>
          <para>If the usage count for the specified service object is now
          zero, the registered service object is cast to a <xref
          linkend="org.osgi.framework.PrototypeServiceFactory"
          xrefstyle="hyperlink"/> object and the <xref
          linkend="org.osgi.framework.PrototypeServiceFactory.ungetService-Bundle-ServiceRegistration-S-"
          xrefstyle="hyperlink"/> method is called to release the specified
          service object . The specified service object must be unreferenced
          by the Framework so it may be garbage collected. See <xref
          linkend="framework.service.prototypeServiceFactory"/> for more
          information about <code>PrototypeServiceFactory</code>
          objects.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="i3081215">
    <title>Service Events</title>

    <itemizedlist>
      <listitem>
        <para><xref linkend="org.osgi.framework.ServiceEvent"
        xrefstyle="hyperlink"/> - Reports registration, unregistration, and
        property changes for service objects. All events of this kind must be
        delivered synchronously. The type of the event is given by the <xref
        linkend="org.osgi.framework.ServiceEvent.getType--"
        xrefstyle="hyperlink"/> method, which returns an <code>int</code>.
        Event types can be extended in the future; unknown event types should
        be ignored.</para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.framework.ServiceListener"
        xrefstyle="hyperlink"/> - Called with a <code>ServiceEvent</code> when
        a service object has been registered or modified, or is in the process
        of unregistering. A security check must be performed for each
        registered listener when a <code>ServiceEvent</code> occurs. The
        listener must not be called unless the bundle which registered the
        listener has the required
        <code>ServicePermission[ServiceReference,GET]</code> for the
        corresponding Service Reference.</para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.framework.AllServiceListener"
        xrefstyle="hyperlink"/> - Services can only be seen when the service
        interface/class is not incompatible with the getter. The <xref
        linkend="org.osgi.framework.AllServiceListener"
        xrefstyle="hyperlink"/> is a marker interface that indicates that the
        getter wants to receive events for all services even if they are
        incompatible. See <xref
        linkend="framework.service.multipleversionexportconsiderations"/>.</para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.framework.UnfilteredServiceListener"
        xrefstyle="hyperlink"/> - Extenders (bundles that can act on behalf of
        other bundles) frequently require unfiltered access to the service
        events for efficiency reasons. However, when they register without a
        filter then the Service Hooks, see <xref
        linkend="framework.servicehooks"/>, cannot provide the filter
        expression to the hooks. This filter information is sometimes
        necessary to detect when certain services are needed. Therefore, the
        <xref linkend="org.osgi.framework.UnfilteredServiceListener"
        xrefstyle="hyperlink"/> interface is a marker interface that instructs
        the framework to never filter service events but still pass the filter
        to the Service Hooks. Extenders should use a single <xref
        linkend="org.osgi.framework.UnfilteredServiceListener"
        xrefstyle="hyperlink"/> object with a compound filter.</para>
      </listitem>
    </itemizedlist>

    <para>A bundle that uses a service object should register a
    <code>ServiceListener</code> object to track the availability of the
    service object, and take appropriate action when the service object is
    unregistering.</para>

    <section xml:id="i3061130">
      <title>Service Event Types</title>

      <para>The following service events are defined:</para>

      <itemizedlist>
        <listitem>
          <para><xref linkend="org.osgi.framework.ServiceEvent.REGISTERED"
          xrefstyle="hyperlink"/> - A service object has been registered. This
          event is synchronously delivered after the service object has been
          registered with the Framework.</para>
        </listitem>

        <listitem>
          <para><xref linkend="org.osgi.framework.ServiceEvent.MODIFIED"
          xrefstyle="hyperlink"/> - The properties of a service have been
          modified. This event is synchronously delivered after the service
          properties have been modified.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.framework.ServiceEvent.MODIFIED_ENDMATCH"
          xrefstyle="hyperlink"/> - Listeners registered with a filter can not
          see the <code>MODIFIED</code> event when a modification makes the
          filter no longer match. The lack of this notification complicates
          tracking a service with a filter. The <code>MODIFIED_ENDMATCH</code>
          event is therefore delivered if the old service properties matched
          the given filter but the modified properties do not. This event is
          synchronously delivered after the service properties have been
          modified.</para>
        </listitem>

        <listitem>
          <para><xref linkend="org.osgi.framework.ServiceEvent.UNREGISTERING"
          xrefstyle="hyperlink"/> - A service object is in the process of
          being unregistered. This event is synchronously delivered before the
          service object has completed unregistering. That is, during the
          delivery of this event, the service object is still valid. The
          bundle receiving this event must release all references to this
          service before this method returns.</para>
        </listitem>
      </itemizedlist>

      <para>New service event types can be added in future
      specifications</para>
    </section>
  </section>

  <section>
    <title>Stale References</title>

    <para>The Framework must manage the dependencies between bundles. This
    management is, however, restricted to Framework structures. Bundles must
    listen to events generated by the Framework to clean up and remove
    <emphasis>stale references</emphasis>.</para>

    <para>A stale reference is a reference to a Java object that belongs to
    the class loader of a bundle that is stopped or is associated with a
    service object that is unregistered. Standard Java does not provide any
    generic means to clean up stale references, and bundle developers must
    analyze their code carefully to ensure that stale references are
    deleted.</para>

    <para>Stale references are potentially harmful because they hinder the
    Java garbage collector from harvesting the classes, and possibly the
    instances, of stopped bundles. This may result in significantly increased
    memory usage and can cause updating native code libraries to fail. Bundles
    using services are strongly recommended to use either the Service Tracker
    or Declarative Services.</para>

    <para>Service developers can minimize the consequences of (but not
    completely prevent) stale references by using the following
    mechanisms:</para>

    <itemizedlist>
      <listitem>
        <para>Implement service objects using the <code>ServiceFactory</code>
        or <code>PrototypeServiceFactory</code> interface. The methods in the
        <code>ServiceFactory</code> and <code>PrototypeServiceFactory</code>
        interface simplify tracking bundles that use their service objects.
        See <xref linkend="framework.service.serviceFactory"/> and <xref
        linkend="framework.service.prototypeServiceFactory"/>.</para>
      </listitem>

      <listitem>
        <para>Use indirection in the service object implementations. Service
        objects handed out to other bundles should use a pointer to the actual
        service implementation. When the service object becomes invalid, the
        pointer is set to <code>null</code>, effectively removing the
        reference to the actual service implementation.</para>
      </listitem>
    </itemizedlist>

    <para>The behavior of a service object that becomes unregistered is
    undefined. Such service objects may continue to work properly or throw an
    exception at their discretion. This type of error should be logged.</para>
  </section>

  <section xml:id="i2671413">
    <title>Filters</title>

    <para>The Framework provides a <xref linkend="org.osgi.framework.Filter"
    xrefstyle="hyperlink"/> interface, and uses a filter syntax in the
    <code>getServiceReferences</code> methods that is defined in <xref
    linkend="framework.module.filtersyntax"/>. Filter objects can be created
    by calling <xref linkend="org.osgi.framework.BundleContext"
    xrefstyle="hyperlink"/>.<xref
    linkend="org.osgi.framework.BundleContext.createFilter-String-"
    xrefstyle="hyperlink"/> or <xref
    linkend="org.osgi.framework.FrameworkUtil" xrefstyle="hyperlink"/>.<xref
    linkend="org.osgi.framework.FrameworkUtil.createFilter-String-"
    xrefstyle="hyperlink"/> with the chosen filter string. The filter supports
    the following match methods:</para>

    <itemizedlist>
      <listitem>
        <para><xref
        linkend="org.osgi.framework.Filter.match-ServiceReference-"
        xrefstyle="hyperlink"/> - Match the properties of the Service
        Reference performing key lookup in a case insensitive way.</para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.framework.Filter.match-Dictionary-"
        xrefstyle="hyperlink"/> - Match the entries in the given
        <code>Dictionary</code> object performing key lookup in a case
        insensitive way.</para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.framework.Filter.matchCase-Dictionary-"
        xrefstyle="hyperlink"/> - Match the entries in the given
        <code>Dictionary</code> object performing key lookup in a case
        sensitive way.</para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.framework.Filter.matches-Map-"
        xrefstyle="hyperlink"/> - Match the entries in the given
        <code>Map</code> object performing key lookup in a case sensitive
        way.</para>
      </listitem>
    </itemizedlist>

    <para>A <code>Filter</code> object can be used numerous times to determine
    if the match argument, a <code>ServiceReference</code> object, a
    <code>Map</code> object, or a <code>Dictionary</code> object, matches the
    filter string that was used to create the <code>Filter</code>
    object.</para>

    <para>This matching requires comparing the value string in the filter to a
    target object from the service properties, dictionary, or map. This
    comparison can be executed with the <code>Comparable</code> interface if
    the target object's class implements the <code>Comparable</code>
    interface. If the target object's class does not implement
    <code>Comparable</code>, the =, ~=, &lt;= &gt;= operators must return only
    true when the objects are equal (using the <code>equals(Object)</code>
    method).</para>

    <para>The value string in the filter can be converted into an object
    suitable for comparison with the target object if the target object's
    class implements either a static <code>valueOf</code> method taking a
    single <code>String</code> object or a constructor taking a single
    <code>String</code> object. That is, if the target object is of class
    <code>Target</code>, the class <code>Target</code> must implement one of
    the following methods:</para>

    <itemizedlist>
      <listitem>
        <para>A static <code>valueOf(String)</code> method whose return type
        is assignable to <code>Target</code></para>
      </listitem>

      <listitem>
        <para>A <code>Target(String)</code> constructor</para>
      </listitem>
    </itemizedlist>

    <para>The <code>Target</code> class does not need to be a public
    class.</para>

    <para>If during the evaluation of the filter a target object throws an
    exception, then this exception must not be re-thrown but caught. The
    result of the evaluation must then be interpreted as
    <code>false</code>.</para>

    <para>The following example shows how a class can verify the ordering of
    an enumeration with a filter.</para>

    <programlisting>public class B implements Comparable {
    String keys[] = {"bugs", "daffy", "elmer", "pepe"};
    int         index;
    
    public B(String s) {
        for ( index=0; index&lt;keys.length; index++ ) 
            if ( keys[index].equals(s) )
                return;
    }
    
    public int compareTo( Object other ) {
        B vother = (B) other;
        return index - vother.index;
    }
 }</programlisting>

    <para>The class could be used with the following filter:</para>

    <programlisting>(!(enum&gt;=elmer))   -&gt; matches bugs and daffy</programlisting>

    <para>The <code>Filter.toString</code> method must always return the
    filter string with unnecessary white space removed.</para>
  </section>

  <section xml:id="framework.service.serviceFactory">
    <title>Service Factory</title>

    <para>A Service Factory allows customization of the service object that is
    returned to a calling bundle. See <xref
    linkend="framework.service.gettingSingle"/>. See also <xref
    linkend="framework.service.prototypeServiceFactory"/>.</para>

    <para>Often, the service object that is registered by a bundle is returned
    directly to all using bundles. Such a service has <xref
    linkend="org.osgi.framework.Constants.SCOPE_SINGLETON"
    xrefstyle="hyperlink"/> scope. If, however, the registered service object
    implements the <xref linkend="org.osgi.framework.ServiceFactory"
    xrefstyle="hyperlink"/> interface, the service has <xref
    linkend="org.osgi.framework.Constants.SCOPE_BUNDLE"
    xrefstyle="hyperlink"/> scope and the Framework must call methods on the
    registered object to obtain a customized service object for each distinct
    bundle that gets the service.</para>

    <para>When the customized service object is no longer used by a bundle -
    for example, when that bundle is stopped - then the Framework must notify
    the <code>ServiceFactory</code> object to release the customized service
    object.</para>

    <para><code>ServiceFactory</code> objects help manage bundle dependencies
    that are not explicitly managed by the Framework. By binding a returned
    service object to the requesting bundle, the service can be notified when
    that bundle ceases to use the customized service object, such as when it
    is stopped, and release resources associated with providing the service to
    that bundle.</para>

    <para>The <code>ServiceFactory</code> interface defines the following
    methods:</para>

    <itemizedlist>
      <listitem>
        <para><xref
        linkend="org.osgi.framework.ServiceFactory.getService-Bundle-ServiceRegistration-"
        xrefstyle="hyperlink"/> - This method is called by the Framework when
        it needs to obtain a customized service object for a requesting
        bundle. See <xref linkend="framework.service.getting"/>.</para>

        <para>The Framework must check the customized service object returned
        by this method. If it is not an instance of all the classes named when
        the Service Factory was registered, <code>null</code> is returned to
        the requesting bundle. This check must be done as specified in <xref
        linkend="framework.service.registeringservices"/>.</para>

        <para>If this method is called recursively for the same bundle then it
        must return <code>null</code> to break the recursion.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.framework.ServiceFactory.ungetService-Bundle-ServiceRegistration-S-"
        xrefstyle="hyperlink"/> - This method is called by the Framework when
        it needs to release a customized service object for a requesting
        bundle. See <xref linkend="framework.service.releasing"/>.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="framework.service.prototypeServiceFactory">
    <title>Prototype Service Factory</title>

    <para>A Prototype Service Factory allows customization of service objects
    and allows multiple service objects to be used by a bundle. See <xref
    linkend="framework.service.gettingMultiple"/>. See also <xref
    linkend="framework.service.serviceFactory"/>.</para>

    <para>Often, the service object that is registered by a bundle is returned
    directly to all using bundles. Such a service has <xref
    linkend="org.osgi.framework.Constants.SCOPE_SINGLETON"
    xrefstyle="hyperlink"/> scope. If, however, the registered service object
    implements the <xref linkend="org.osgi.framework.PrototypeServiceFactory"
    xrefstyle="hyperlink"/> interface, the service has <xref
    linkend="org.osgi.framework.Constants.SCOPE_PROTOTYPE"
    xrefstyle="hyperlink"/> scope and the Framework must call methods on the
    registered service object to create customized service object instances
    for each call to <xref linkend="org.osgi.framework.ServiceObjects"
    xrefstyle="hyperlink"/>.<xref
    linkend="org.osgi.framework.ServiceObjects.getService--"
    xrefstyle="hyperlink"/>. Services with <xref
    linkend="org.osgi.framework.Constants.SCOPE_PROTOTYPE"
    xrefstyle="hyperlink"/> are useful for service objects that maintain state
    for the duration of usage and the using bundles require multiple service
    objects at the same time.</para>

    <para>When the customized service objects are no longer used by a bundle -
    for example, when that bundle is stopped - then the Framework must notify
    the <code>PrototypeServiceFactory</code> object to release all the
    customized service objects.</para>

    <para><code>PrototypeServiceFactory</code> objects help manage bundle
    dependencies that are not explicitly managed by the Framework. By binding
    a returned service object to the requesting bundle and optionally some
    other stateful information, the Prototype Service Factory can be notified
    when that bundle ceases to use a customized service object, such as when
    it is stopped, and release resources associated with providing a
    customized service object to that bundle.</para>

    <para>The <code>PrototypeServiceFactory</code> interface defines the
    following methods:</para>

    <itemizedlist>
      <listitem>
        <para><xref
        linkend="org.osgi.framework.PrototypeServiceFactory.getService-Bundle-ServiceRegistration-"
        xrefstyle="hyperlink"/> - This method is called by the Framework when
        it needs to obtain a customized service object for a requesting
        bundle. See <xref linkend="framework.service.getting"/>.</para>

        <para>The Framework must check the customized service object returned
        by this method. If it is not an instance of all the classes named when
        the Service Factory was registered, <code>null</code> is returned to
        the requesting bundle. This check must be done as specified in <xref
        linkend="framework.service.registeringservices"/>.</para>

        <para>For each customized services object returned by this method, the
        Framework must hold a reference to it until it is released. This is
        necessary so the Framework can release all unused and unreleased
        customized service objects - for example, when a requesting bundle is
        stopped or the service object is unregistered.</para>

        <para>Since this method can return the same service object repeatedly,
        the framework must maintain a usage count for each customized service
        object so that it is only released when its usage count returns to
        zero.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.framework.PrototypeServiceFactory.ungetService-Bundle-ServiceRegistration-S-"
        xrefstyle="hyperlink"/> - This method is called by the Framework when
        it needs to release a customized service object for a requesting
        bundle. See <xref linkend="framework.service.releasing"/>.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="i1180814">
    <title>Unregistering Services</title>

    <para>The <code>ServiceRegistration</code> interface defines the <xref
    linkend="org.osgi.framework.ServiceRegistration.unregister--"
    xrefstyle="hyperlink"/> method to unregister the service object. This must
    remove the service object from the Framework service registry. Any
    <code>ServiceReference</code> object for this
    <code>ServiceRegistration</code> object can no longer be used to access
    the service object.</para>

    <para>The fact that this method is on the <code>ServiceRegistration</code>
    object ensures that only the bundle holding this object can unregister the
    associated service object. The bundle that unregisters a service object,
    however, might not be the same bundle that registered it. As an example,
    the registering bundle could have passed the
    <code>ServiceRegistration</code> object to another bundle, endowing that
    bundle with the responsibility of unregistering the service object.
    Passing <code>ServiceRegistration</code> objects should be done with
    caution.</para>

    <para>After <xref
    linkend="org.osgi.framework.ServiceRegistration.unregister--"
    xrefstyle="hyperlink"/> successfully completes, the service objects must
    be:</para>

    <itemizedlist>
      <listitem>
        <para>Completely removed from the Framework service registry.
        Therefore, <code>ServiceReference</code> objects obtained for that
        service object can no longer be used to access a service object.
        Attempts to get a service object must return <code>null</code>.</para>
      </listitem>

      <listitem>
        <para>Unregistered, even if other bundles had dependencies upon it.
        Bundles must be notified of the unregistration through the publishing
        of a <code>ServiceEvent</code> of type <xref
        linkend="org.osgi.framework.ServiceEvent.UNREGISTERING"
        xrefstyle="hyperlink"/>. This event is sent synchronously in order to
        give bundles the opportunity to release service objects.</para>

        <para>After receiving an event of type <xref
        linkend="org.osgi.framework.ServiceEvent.UNREGISTERING"
        xrefstyle="hyperlink"/>, a bundle should release the service objects
        and release any references it has to the service objects, so that the
        service objects can be garbage collected by the Java VM.</para>
      </listitem>

      <listitem>
        <para>Released by all using bundles. For each bundle with unreleased
        service objects after all invoked <code>ServiceListener</code> objects
        have returned, the Framework must release all the service
        objects.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="framework.service.multipleversionexportconsiderations">
    <title>Multiple Version Export Considerations</title>

    <para>Allowing multiple bundles to export a package with a given name
    causes some complications for Framework implementers and bundle
    programmers: The class name no longer uniquely identifies the exported
    class. This affects the service registry and permission checking.</para>

    <section>
      <title>Service Registry</title>

      <para>Bundles must not be exposed to service objects for which there are
      conflicting class loaders. A bundle that gets a service object should be
      able to expect that it can safely cast the service object to any of the
      associated interfaces or classes under which the service object was
      registered and that it can access. No <code>ClassCastExceptions</code>
      should occur because those interfaces do not come from the same class
      loader. The service registry must therefore ensure that bundles can only
      see service objects that are <emphasis>not incompatible</emphasis> with
      the bundle. A service object is not incompatible with the bundle getting
      the service object when that bundle is not wired to another source class
      loader for this interface package than the bundle registering the
      service object. That is, it is either wired to the same source class
      loader or it has no wire for that package at all.</para>

      <para>It is paramount that bundles are not accidentally confronted with
      incompatible service objects. Therefore, the following methods need to
      filter <code>ServiceReference</code> objects depending on the
      incompatibility of the interfaces with the calling bundle and only
      return Service Reference objects for services object that are not
      incompatible with the calling bundle for the specified interface. The
      bundle is identified by the used Bundle Context:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.framework.BundleContext.getServiceReference-String-"
          xrefstyle="hyperlink"/></para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.framework.BundleContext.getServiceReference-Class-"
          xrefstyle="hyperlink"/></para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.framework.BundleContext.getServiceReferences-String-String-"
          xrefstyle="hyperlink"/></para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.framework.BundleContext.getServiceReferences-Class-String-"
          xrefstyle="hyperlink"/></para>
        </listitem>
      </itemizedlist>

      <para>The <xref
      linkend="org.osgi.framework.BundleContext.getAllServiceReferences-String-String-"
      xrefstyle="hyperlink"/> method provides access to the service registry
      without any compatibility restrictions. Service References acquired
      through this method can be used to obtain service objects which can
      cause a Class Cast Exception when casting to the specified class
      name.</para>

      <para>The <xref linkend="org.osgi.framework.ServiceReference"
      xrefstyle="hyperlink"/>.<xref
      linkend="org.osgi.framework.ServiceReference.isAssignableTo-Bundle-String-"
      xrefstyle="hyperlink"/> method is also available to test if the bundle
      that registered the service object referenced by this ServiceReference
      and the specified bundle are both wired to same source for the specified
      interface.</para>
    </section>

    <section xml:id="i3081203">
      <title>Service Events</title>

      <para>Service events must only be delivered to event listeners
      registered by bundles that are not incompatible with the referenced
      service object.</para>

      <para>Some bundles need to listen to all service events regardless of
      any compatibility issues. A special type of ServiceListener can
      therefore be used: <xref linkend="org.osgi.framework.AllServiceListener"
      xrefstyle="hyperlink"/>. This is a marker interface; it extends <xref
      linkend="org.osgi.framework.ServiceListener" xrefstyle="hyperlink"/>.
      Listeners that use this marker interface indicate to the Framework that
      the bundle registering the event listener wants to see events for all
      services, including for service objects that are incompatible with the
      bundle.</para>
    </section>
  </section>

  <section>
    <title>Security</title>

    <section xml:id="i3043587">
      <title>Service Permission</title>

      <para>A <code>ServicePermission</code> has the following
      parameters.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>target</emphasis> - Either the interface name or a
          filter expression for the <code>GET</code> action. The interface
          name may end with a wildcard to match multiple interface names. See
          <code>java.security.BasicPermission</code> for a discussion of
          wildcards. Filters are explained in <xref
          linkend="framework.security.filterbasedpermissions"/>. The filter
          expression can additionally test for the service interface name with
          the <code>objectClass</code> key. Additionally, a service permission
          can also test for service properties that are part of the service
          registration. In general, all the service properties are usable in
          the filter expression. However, when there is a name conflict with
          the bundle identification properties, then the key can be prefixed
          with the commercial at sign (<code>'@' \u0040</code>). For example,
          @id will refer to a service property with the name id.</para>
        </listitem>

        <listitem>
          <para><emphasis>action</emphasis> - Supported actions are:</para>

          <itemizedlist>
            <listitem>
              <para><code>REGISTER</code> - Indicates that the permission
              holder may register the service object</para>
            </listitem>

            <listitem>
              <para><code>GET</code> - Indicates that the holder may get the
              service.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>When an object is being registered as a service object using
      <code>BundleContext.registerService</code>, the registering bundle must
      have the <code>ServicePermission</code> to register all the named
      classes. See <xref
      linkend="framework.service.registeringservices"/>.</para>

      <para>When a <code>ServiceReference</code> object is obtained from the
      service registry, see <xref linkend="framework.service.locating"/>, the
      calling bundle must have the required
      <code>ServicePermission[ServiceReference, GET]</code> to get the service
      object for each returned Service Reference.</para>

      <para>When a service object is obtained using a
      <code>ServiceReference</code> object, see <xref
      linkend="framework.service.getting"/>, the calling code must have the
      required <code>ServicePermission[ServiceReference, GET]</code> to get
      the service object associated with the Service Reference.</para>

      <para><code>ServicePermission</code> must be used as a filter for the
      service events received by the Service Listener, as well as for the
      methods to enumerate services, including
      <code>Bundle.getRegisteredServices</code> and
      <code>Bundle.getServicesInUse</code>. The Framework must assure that a
      bundle must not be able to detect the presence of a service that it does
      not have permission to access.</para>
    </section>
  </section>
</chapter>
